## 为科学家服务的fortran
- fortran是为科学家服务的.
- 在数学上, 向量默认为列向量
- 所以, 如果从科学家的角度来考虑, 按列优先存储, 天经地义. 以为如果我要读取一个列向量, 直接连续读取就可以, 很方便.

---

`内存中是没有行列的概念的`, 不管是二维数组,还是N维的tensor,在内存中都是一条线.

在这个物理存储的层面上, Fortran和C是没有区别的.

`下面表示 [1,2,3,4,5,6,7,8]`

![image](https://github.com/qiaohaijun/mycpt-notes/blob/master/img/blas/fortran%E8%A1%8C%E5%88%97%E5%AD%98%E5%82%A8.gif?raw=true)


他们对应内存中的地址，可能为 0x0041F100 , 0x0041F104 , 0x0041F108 ...... 一直到 0x0041F11C。这些地址是采用十六进制表述的，且只是假设，真实的地址会与他们类似。由于绝大多数 32 位编译器的整数和浮点数，都占有 4 个字节，因此，这些地址之间各相差 4 字节。（如无法理解本段落，问题也不大）


高级语言通常不会直接访问内存地址，所以 Fortran 和 C 使用数组来“命名”这些内存地址，并且通过数组+下标来访问这些内存地址。


#### fortran从1开始,c语言从0开始
如果把这一段内存地址视为 8 元素的一维数组，Fortran 和 C 的规则差别不大，Fortran 默认以 1 开头，而 C 则以 0 开头。



### 如果把这一段内存地址视为 2*4 元素的二维数组，则 Fortran 和 C 还有另一个差异:

#### fortran 会首先变化前面的维度
Fortran 会先变化前面的维度，即顺序为 a(1,1) , a(2,1) .... 前面的 1 先变化为 2，后面维度始终保持为 1。直到循环完毕后，再将后面的维度加一，即 a(1,2) , a(2,2).....

#### c语言会首先变化后面的维度
C 语言则相反，会先变化后面的维度，即顺序为 a[0][0] , a[0][1] .... 后面的 0 先变化为 1，前面维度始终保持为 0。直到循环完毕后，再将前面的维度加一，即 a[1][0] , a[1][1].....

#### fortran和c语言的下标对应关系
因此，对于二维数组来说，Fortran 的 a( m , n ) 默认情况下，对应于 C 语言的 a[n-1][m-1]。如果读者做两者的混合编程，这一点很重要。

---
不管如何“命名”和“取值”，内存中，始终是8个数据“一条线”排列着，`内存中没有行，列的概念！`
实际上，如果不书写出来的话，二维数组本来也没有统一的行列概念。a( m , n ) 你可以把 m 叫做行而把 n 叫做列，也可以把 n 叫做行而把 m 叫做列。

但是，为了人们交流的方便，大家习惯上，把前面的维度称为列，后面的维度称为行。由于 Fortran 命名时先改变前面的维度，因此，人们习惯称之为 “列优先"

另外，Fortran 允许对整个数组进行操作。如果代码书写为： write( * , * ) a 或 write( * , * ) a( : , : ) 则编译器会按照上图的顺序来输出 a 数组。这也是 列优先 方式的表现。



----

## 参考
- https://www.zhihu.com/question/21766240
- http://fcode.cn/guide-45-1.html

